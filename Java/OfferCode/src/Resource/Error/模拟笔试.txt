下面哪个标识符是合法的？ (D)
A. 9HelloWorld
B. _Hello World  \
C. Hello*World
D. Hello$World

-----------------------------------------------------------------------------------------------------------
将下列哪个代码（A、B、C、D）放入程序中标注的【代码】处将导致编译错误？ (B)

    class A{
        public float getNum(){
            return 3.0f;
        }
    }
    public class B extends A{
        【代码】
    }

A. public float getNum(){return 4.0f;}
B. public void getNum(){}
C. public void getNum(double d){}
D. public double getNum(float d){return 4.0d;}

方法重写要求方法名，返回值类型，参数完全相同，所以A符合，
                B返回值类型不同，编译错误。
                而C和D不仅返回值类型不同，参数也不同，不属于方法重写，而是属于子类自己新增的方法。
                所以选B

重写与重载之间的区别
区别点	重载方法	重写方法
参数列表	必须修改	一定不能修改
返回类型	可以修改	一定不能修改
异常	    可以修改	可以减少或删除，一定不能抛出新的或者更广的异常
访问	    可以修改	一定不能做更严格的限制（可以降低限制）


重载规则:

被重载的方法必须改变参数列表(参数个数或类型不一样)；
被重载的方法可以改变返回类型；
被重载的方法可以改变访问修饰符；
被重载的方法可以声明新的或更广的检查异常；
方法能够在同一个类中或者在一个子类中被重载。
无法以返回值类型作为重载函数的区分标准。

-----------------------------------------------------------------------------------------------------------


如下代码的输出结果是什么？ （D）
    public class Test {
         public int aMethod(){
         static int i = 0;      // static 编译失败，方法不是静态的，变量是静态的
         i++;
         return i;
     }
    public static void main(String args[]){
         Test test = new Test();
         test.aMethod();
         int j = test.aMethod();
         System.out.println(j);
         }
    }

A. 0
B. 1
C. 2
D、编译失败

-----------------------------------------------------------------------------------------------------------

jre 判断程序是否执行结束的标准是（A）
A.所有的前台线程执行完毕
B. 所有的后台线程执行完毕
C. 所有的线程执行完毕
D. 和以上都无关

前台线程和后台线程的区别和联系：
1、后台线程不会阻止进程的终止。属于某个进程的所有前台线程都终止后，该进程就会被终止。所有剩余的后台线程都会停止且不会完成。
2、可以在任何时候将前台线程修改为后台线程，方式是设置Thread.IsBackground 属性。
3、不管是前台线程还是后台线程，如果线程内出现了异常，都会导致进程的终止。
4、托管线程池中的线程都是后台线程，使用new Thread方式创建的线程默认都是前台线程。



-----------------------------------------------------------------------------------------------------------

String,StringBuilder,StringBuffer

2.2、性能
每次对 String 类型进行改变的时候，都会生成一个新的string对象，然后将指针指向新的String 对象。Stringsuffer 每次都会对 stringBuffer对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用StringBuilder相比使用
stringBuffer仅能获得10%~15%左右的性能提升，但却要冒多线程不安全的风险。
2.3、对于三者使用的总结
1.操作少量的数据:适用String
2.单线程操作字符串缓冲区下操作大量数据:适用stringBui1der3.多线程操作字符串缓冲区下操作大量数据:适用`stringBuffer

-----------------------------------------------------------------------------------------------------------

以下代码段执行后的输出结果为  (-2)
public class Test {
    public static void main(String args[]) {
        int x = 5;
        int y = -12;
        System.out.println(y % x);
    }
}

A. -1
B. 2
C. 1

取模的结果符号根据被模数y的符号走，（正常进行计算就好）

-----------------------------------------------------------------------------------------------------------

https://www.cnblogs.com/yuandluck/p/9476250.html

下面有关JVM内存，说法错误的是？ (C)
    A. 程序计数器是一个比较小的内存区域，用于指示当前线程所执行的字节码执行到了第几行，是线程隔离的
    B. Java方法执行内存模型，用于存储局部变量，操作数栈，动态链接，方法出口等信息，是线程隔离的
    C. 方法区用于存储JVM加载的类信息、常量、静态变量、即时编译器编译后的代码等数据，是线程隔离
    D. 原则上讲，所有的对象都在堆区上分配内存，是线程之间共享的

栈和堆的区别(都是在jvm中)
只有方法区和堆是所有线程共享的数据区域

使用方法
栈内存用来存储局部变量和方法调用
堆内存用来存储Java中的对象。无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中
作用范围
栈内存归属于单个线程，每个线程都会有一个栈内存，其存储的变量只能在其所属线程中可见，即栈内存可以理解成线程的私有内存。
堆内存中的对象对所有线程可见。堆内存中的对象可以被所有线程访问。
异常错误
栈内存没有可用的空间存储方法调用和局部变量，JVM会抛出java.lang.StackOverFlowError。
堆内存没有可用的空间存储生成的对象，JVM会抛出java.lang.OutOfMemoryError。
占用空间
栈的内存要远远小于堆内存，如果你使用递归的话，那么你的栈很快就会充满。如果递归没有及时跳出，很可能发生stackOverFlowError问题。

-----------------------------------------------------------------------------------------------------------

接口的方法必须是public类型，且实现接口必须实现所有方法


在类设计中，类的成员变量要求仅仅能够被同一package下的类访问，请问应该使用下列哪个修饰词（D)
    A. protected
    B. public
    C. private
    D. 不需要任何修饰词(default)

-----------------------------------------------------------------------------------------------------------

以下方法，哪个不是对add方法的重载? (B)
    public class Test
    {
     public void add( int x,int y,int z){}
    }

    A. public int add(int x,int y,float z){return 0;}
    B. public int add(int x,int y,int z){return 0;}
    C. public void add(int x,int y){}
    D. 所有选项都不是

重载对于参数列表必须修改，返回值类型、异常、访问可以修改。

-----------------------------------------------------------------------------------------------------------

数据类型	                               默认值
基本类型	整数（byte，short，int，long)	     0
浮点数 （ﬂoat，double）	                 0.0
字符（char）	                            ‘\u0000’
布尔（boolean）	                         false
引用数据类型	引用类型 数组，类，接口	     null


-----------------------------------------------------------------------------------------------------------

volatile关键字的说法错误的是 (A)
    A.能保证线程安全
    B.volatile关键字用在多线程同步中，可保证读取的可见性
    C.JVM保证从主内存加载到线程工作内存的值是最新的
    D.volatile能禁止进行指令重排序


A选项：volatile单纯使用不能保证线程安全，他只是提供了一种弱的同步机制来确保修饰的变量的更新操作通知到其他线程，A选项说法错误
B选项：对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。B选项说法正确。
C选项： 对于用volatile修饰的变量，JVM虚拟机会保证从主内存加载到线程工作内存的值是最新的，例如线程1和线程2在进行read和load
的操作中，发现主内存中某个变量的值都是5，那么都会加载这个最新的值。这也是可见性的一种体现。C选项说法正确。
D选项：volatile的底层是采用内存屏障来实现的，就是在编译器生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排
序。D选项说法正确。
综上所述，答案选择A

-----------------------------------------------------------------------------------------------------------

下面关于abstract关键字描述错误的是（D）
    A. abstract关键字可以修饰类或方法
    B. final类的方法都不能是abstract，因为final类不能有子类
    C. abstract类不能实例化
    D. abstract类的子类必须实现其超类的所有abstract方法

抽象类的使用原则如下：
（1）抽象方法必须为public或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public；
（2）抽象类不能直接实例化，需要依靠子类采用向上转型的方式处理；
（3）抽象类必须有子类，使用extends继承，一个子类只能继承一个抽象类；
（4）子类（如果不是抽象类）则必须覆写抽象类之中的全部抽象方法（如果子类没有实现父类的抽象方法，则必须将子类也定义为为abstract类。）；

补充： 类是否都要实现接口
1.结论
    并不是所有的类实现接口后都必须实现接口的所有方法！

2.特殊情况
    当Java抽象类实现某个接口后没必要实现所有的方法。

3.注意点
    当Java普通类实现接口后必须实现接口中的所有方法。

-----------------------------------------------------------------------------------------------------------

下面有关JAVA异常类的描述，说法错误的是？ (D)
    A. 异常的继承结构：基类为Throwable，Error和Exception继承Throwable，RuntimeException和IOException等继承Exception
    B. 非RuntimeException一般是外部错误(非Error)，其一般被 try{}catch语句块所捕获
    C. Error类体系描述了Java运行系统中的内部错误以及资源耗尽的情形，Error不需要捕捉
    D. RuntimeException体系包括错误的类型转换、数组越界访问和试图访问空指针等等，必须被 try{}catch语句块所捕获

受查异常（checked）
比如：
    IOException（同输入输出相关的操作，如无效输入，打开一个不存在在文件）
    ClassNotFoundException（使用不存在的类）

非受查异常（unchecked）
比如：
    ArithmeticException（算数异常）
    NullPointerException（指向对象为空异常）
    IndexOutOfBoundsException（数组超标异常）
    IllegalArgumentException（传递非法参数异常）
    RuntimeException和Error


RuntimeException和Error属于非受查异常 (unchecked)，Java编译器在运行程序之前无法发现这样的异常，所以不需要捕获。
受检查异常是你必须要捕获的异常,否则无法通过编译, 而非受检查异常你可以捕获或者不捕获.

-----------------------------------------------------------------------------------------------------------

关于PreparedStatement与Statement描述错误的是（D）
    A.一般而言，PreparedStatement比Statement执行效率更高
    B.PreparedStatement会预编译SQL语句
    C.Statement每次都会解析/编译SQL，确立并优化数据获取路径
    D.Statement执行扫描的结果集比PreparedStatement大

    链接：https://www.nowcoder.com/questionTerminal/7197bae4575b4169843c75aad0387e21?
    来源：牛客网

    1:创建时的区别：
        Statement statement = conn.createStatement();
        PreparedStatement preStatement = conn.prepareStatement(sql);
        执行的时候:
        ResultSet rSet = statement.executeQuery(sql);
        ResultSet pSet = preStatement.executeQuery();

    由上可以看出，PreparedStatement有预编译的过程，已经绑定sql，之后无论执行多少遍，都不会再去进行编译，

    而 statement 不同，如果执行多变，则相应的就要编译多少遍sql，所以从这点看，preStatement 的效率会比 Statement要高一些

    2>安全性问题

    这个就不多说了，preStatement是预编译的，所以可以有效的防止 SQL注入等问题

    所以 preStatement 的安全性 比 Statement 高

    3>代码的可读性 和 可维护性
    这点也不用多说了，你看老代码的时候  会深有体会

    preStatement更胜一筹

    preparedstatement和statement执行结果（本题中表达成扫描结果）应该是相同的,区别只是在于他们执行前的准备工作,
    statement每次执行都会对SQL做分析,而preparedstatement对相同的SQL只做一次分析,
    所以很明显preparedstatement对批量执行可以提升效率,但查询的结果（扫描的结果集）应该都是一样的

-----------------------------------------------------------------------------------------------------------

仅仅提交更新部分的数据而不是全部数据违反了数据库的什么规则？（A）
    A. 原子性
    B. 一致性
    C. 隔离性
    D. 持久性

数据库事务的四大特性的是： 原子性，一致性，隔离性，持久性

隔离性（Isolation）
     解决脏读，幻读，不可重复读，
持久性（Durability）
     事务提交后，对系统的影响是永久的。

-----------------------------------------------------------------------------------------------------------

SQL语句性能分析的关键字是什么？(A)
    A. EXPLAIN （解释）
    B. LOAD
    C. TOP
    D. SUM

下面有关jdbc statement的说法错误的是？(C)
    A. JDBC提供了Statement、PreparedStatement 和 CallableStatement三种方式来执行查询语句，其中 Statement 用于通用查询， PreparedStatement 用于执行参数化
    查询，而 CallableStatement则是用于存储过程
    B. 对于PreparedStatement来说，数据库可以使用已经编译过及定义好的执行计划，由于 PreparedStatement 对象已预编译过，所以其执行速度要快于 Statement 对
    象”
    C. PreparedStatement中，“?” 叫做占位符，一个占位符可以有一个或者多个值
    D. PreparedStatement可以阻止常见的SQL注入式攻击

一个占位符只能有一个值

-----------------------------------------------------------------------------------------------------------

主机甲与主机乙之间已建立了一个 TCP 链接，主机甲向主机乙发送了两个连续的 TCP 段，分别包含 300 字节和 500 字节的有效载荷，第一个报文段序号为 200 ，主机乙
正确接受到两个段后，发送给主机甲的确认序列号是 ( D)
A. 500
B. 700
C. 800
D. 1000

200+300+500

-----------------------------------------------------------------------------------------------------------

以下关于多线程的叙述中错误的是（B）
    A. 线程同步的方法包括使用临界区，互斥量，信号量等
    B. 两个线程同时对简单类型全局变量进行写操作也需要互斥
    C. 实现可重入函数时，对自动变量也要用互斥量加以保护
    D. 可重入函数不可以调用不可重入函数

可重入函数可认为是可以被中断的函数，自动变量定义的时候才被创建，函数返回时，系统回收空间，他是的是局部作用域变量，不需要互斥量。
可重入函数对全局变量才需要互斥量保护。

-----------------------------------------------------------------------------------------------------------

各种排序算法的时间复杂度
快排、归并、堆排 ：       nlog2（n）/ nlog(n)
冒泡、选择、插入、希尔：    n²
基数排序：               n
稳定排序：               归并，冒泡，插入,基数排序
不稳定排序：              快排，堆排，选择，希尔

-----------------------------------------------------------------------------------------------------------

对记录（54,38,96,23,15,72,60,45,83）进行从小到大的直接插入排序时，当把第8个记录45插入到有序表时，为找到插入位置需比较（ C）次？（采用从后往前比较）
A. 3
B. 4
C. 5
D. 6

38,54,96,23,15,72,60,45,83
38,54,96,23,15,72,60,45,83
23,38,54,96,15,72,60,45,83
15,23,38,54,96,72,60,45,83
15,23,38,54,72,96,60,45,83
15,23,38,54,60,72,96,45,83  <-----
15,23,38,45,54,60,72,96,83
15,23,38,45,54,60,72,83,96

-----------------------------------------------------------------------------------------------------------
https://blog.csdn.net/m0_52322019/article/details/121081521
叶子结点的个数等于度为2的结点数+1.

一棵二叉树高度为h（根的高度为1），所有结点的度是0或2，则这棵二叉树最少有多少个结点（C）
A. 2h
B. 2h + 1
C. 2h - 1
D. h + 1
    根节点有一个结点，每层都两个结点